package com.uptoser.java.javase.classobject;

/**
 * 垃圾回收
 *
 * 垃圾回收机制具有如下特征。
 * ➢ 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（例如数据库连接、网络IO等资源）。
 * ➢ 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行。当对象永久性地失去引用后，系统就会在合适的时候回收它所占的内存。
 * ➢ 在垃圾回收机制回收任何对象之前，总会先调用它的finalize()方法，该方法可能使该对象重新复活（让一个引用变量重新引用该对象），从而导致垃圾回收机制取消回收。
 */
public class GarbageCollection {
    /*
    当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以把它所处的状态分成如下三种。
    ➢ 可达状态：当一个对象被创建后，若有一个以上的引用变量引用它，则这个对象在程序中处于可达状态，程序可通过引用变量来调用该对象的实例变量和方法。
    ➢ 可恢复状态：如果程序中某个对象不再有任何引用变量引用它，它就进入了可恢复状态。在这种状态下，系统的垃圾回收机制准备回收该对象所占用的内存，
    在回收该对象之前，系统会调用所有可恢复状态对象的finalize()方法进行资源清理。如果系统在调用finalize()方法时重新让一个引用变量引用该对象，
    则这个对象会再次变为可达状态；否则该对象将进入不可达状态。
    ➢ 不可达状态：当对象与所有引用变量的关联都被切断，且系统已经调用所有对象的finalize()方法后依然没有使该对象变成可达状态，
    那么这个对象将永久性地失去引用，最后变成不可达状态。只有当一个对象处于不可达状态时，系统才会真正回收该对象所占有的资源。
     */

    /*
    强制垃圾回收
    程序无法精确控制Java垃圾回收的时机,大部分时候,程序强制系统垃圾回收后总会有一些效果
    ➢ 调用System类的gc()静态方法：System.gc()。
    ➢ 调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc()。
     */

    /**
     * 当finalize()方法返回后，对象消失，垃圾回收机制开始执行，finalize()方法并不一定会被执行
     *
     * finalize()方法具有如下4个特点。
     * ➢ 永远不要主动调用某个对象的finalize()方法，该方法应交给垃圾回收机制调用。
     * ➢ finalize()方法何时被调用，是否被调用具有不确定性，不要把finalize()方法当成一定会被执行的方法。
     * ➢ 当JVM执行可恢复对象的finalize()方法时，可能使该对象或系统中其他对象重新变成可达状态。
     * ➢ 当JVM执行finalize()方法时出现异常时，垃圾回收机制不会报告异常，程序继续执行。
     *
     * @throws Throwable
     */
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
    }

    /*
    程序里会有一个引用变量引用该对象，这是最常见的引用方式。
    除此之外，java.lang.ref包下提供了三个类：SoftReference、PhantomReference和WeakReference，
    它们分别代表了系统对对象的三种引用方式：软引用、虚引用和弱引用

    1.强引用（StrongReference）
    这是Java程序中最常见的引用方式。程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象，
    对象和数组都采用了这种强引用的方式。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。
    2.软引用（SoftReference）
    软引用需要通过SoftReference类来实现，当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，
    当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。
    3.弱引用（WeakReference）
    弱引用通过WeakReference类实现，弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，
    不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收—正如那些失去引用的对象一样，
    必须等到系统垃圾回收机制运行时才会被回收。
    4.虚引用（PhantomReference）
    虚引用通过PhantomReference类实现，虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。
    如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，
    虚引用必须和引用队列（ReferenceQueue）联合使用。
     */
}
